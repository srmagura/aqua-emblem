// Generated by CoffeeScript 1.8.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _enc.Battle = (function(_super) {
    __extends(Battle, _super);

    function Battle(ui, atk, def, dist) {
      this.ui = ui;
      this.atk = atk;
      this.def = def;
      this.dist = dist != null ? dist : null;
      this.afterReceiveItem = __bind(this.afterReceiveItem, this);
      this.afterWeaponBreak = __bind(this.afterWeaponBreak, this);
      this.encounterDone = __bind(this.encounterDone, this);
      this.doAction = __bind(this.doAction, this);
      if (this.dist == null) {
        this.dist = this.atk.pos.distance(this.def.pos);
      }
      this.mpTaken = false;
      this.atk.calcCombatStats();
      this.def.calcCombatStats();
      this.calcBattleStats();
    }

    Battle.prototype.calcBattleStats = function() {
      var defCanAttack;
      this.atk.advantage = null;
      this.def.advantage = null;
      this.calcAdvantage(this.atk, this.def);
      this.calcAdvantage(this.def, this.atk);
      this.calcIndividual(this.atk, this.def);
      this.calcIndividual(this.def, this.atk);
      this.turns = [this.atk];
      this.nTurns = {
        atk: 1,
        def: 0
      };
      defCanAttack = (this.def.equipped != null) && this.def.equipped.range.contains(this.dist) && !this.def.hasStatus(_status.Defend);
      if (defCanAttack) {
        this.turns.push(this.def);
        this.nTurns.def++;
      }
      if (this.atk.attackSpeed - 4 > this.def.attackSpeed && this.atk.equipped.hasUses(2)) {
        this.turns.push(this.atk);
        this.nTurns.atk++;
      } else if (defCanAttack && this.def.attackSpeed - 4 > this.atk.attackSpeed && this.def.equipped.hasUses(2)) {
        this.turns.push(this.def);
        this.nTurns.def++;
      }
      return this.attacksHit = 0;
    };

    Battle.prototype.calcAdvantage = function(unit1, unit2) {
      var Axe, Lance, Sword, t1, t2;
      if (!((unit1.equipped != null) && (unit2.equipped != null))) {
        return;
      }
      t1 = unit1.equipped.type;
      t2 = unit2.equipped.type;
      Sword = _skill.type.Sword;
      Lance = _skill.type.Lance;
      Axe = _skill.type.Axe;
      if ((t1 instanceof Sword && t2 instanceof Axe) || (t1 instanceof Axe && t2 instanceof Lance) || (t1 instanceof Lance && t2 instanceof Sword)) {
        unit1.advantage = true;
        return unit2.advantage = false;
      }
    };

    Battle.prototype.calcIndividual = function(unit1, unit2) {
      var defOrRes, factor, key, strOrMag, value, w1, _ref, _results;
      w1 = unit1.equipped;
      if (w1 == null) {
        return;
      }
      unit1.battleStats = {};
      if (!w1.range.contains(this.dist)) {
        return;
      }
      if (w1.type instanceof _skill.type.Physical) {
        strOrMag = unit1.str;
        defOrRes = unit2.def + unit2.defResBonus;
      } else if (w1.type instanceof _skill.type.Magic) {
        strOrMag = unit1.mag;
        defOrRes = unit2.res + unit2.defResBonus;
      }
      unit1.battleStats.hit = unit1.hit - unit2.evade;
      unit1.battleStats.dmg = strOrMag + w1.might - defOrRes;
      unit1.battleStats.crt = unit1.crit - unit2.critEvade;
      if (unit1.advantage === true) {
        factor = 1;
      } else if (unit1.advantage === false) {
        factor = -1;
      } else {
        factor = 0;
      }
      unit1.battleStats.hit += factor * 15;
      unit1.battleStats.dmg += factor * 1;
      if (unit2.hasStatus(_status.Defend)) {
        unit1.battleStats.dmg = Math.round(unit1.battleStats.dmg / 2);
      }
      _ref = unit1.battleStats;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        if (value < 0) {
          unit1.battleStats[key] = 0;
        }
        if ((key === 'hit' || key === 'crt') && value > 100) {
          _results.push(unit1.battleStats[key] = 100);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Battle.prototype.getPlayerUnit = function() {
      if (this.atk.team instanceof _team.PlayerTeam) {
        return this.atk;
      } else {
        return this.def;
      }
    };

    Battle.prototype.getEnemyUnit = function() {
      return this.getOther(this.getPlayerUnit());
    };

    Battle.prototype.doAction = function() {
      var callMade, dmg, giver, randCrit, randHit, recvr;
      callMade = false;
      giver = this.turns[this.turnIndex];
      recvr = this.getOther(giver);
      this.doLunge(giver);
      randHit = 100 * Math.random();
      if (randHit < giver.battleStats.hit) {
        dmg = giver.battleStats.dmg;
        randCrit = 100 * Math.random();
        if (randCrit < giver.battleStats.crt) {
          this.displayMessage(recvr, 'crit');
          dmg *= 3;
        }
        recvr.hp -= dmg;
        if (dmg === 0) {
          this.displayMessage(recvr, 'no-dmg');
        }
        if (giver === this.getPlayerUnit()) {
          if (giver.equipped.mp != null) {
            if (!this.mpTaken) {
              giver.mp -= giver.equipped.mp;
              this.mpTaken = true;
            }
          } else if (giver.mp < giver.maxMp) {
            giver.mp++;
            if (giver.equipped.uses != null) {
              giver.equipped.uses--;
            }
          }
          this.attacksHit++;
        }
      } else {
        this.displayMessage(recvr, 'miss');
      }
      if (recvr.hp <= 0) {
        recvr.hp = 0;
        setTimeout(this.encounterDone, this.delay);
        callMade = true;
      }
      this.turnIndex++;
      if (!callMade) {
        if (this.turnIndex === this.turns.length) {
          setTimeout(this.encounterDone, this.delay);
        } else {
          setTimeout(this.doAction, this.delay);
        }
      }
      this.atkBox.init(this.atk, true);
      return this.defBox.init(this.def, true);
    };

    Battle.prototype.showSkillMessage = function(skill) {
      var afterDelay, afterFadeIn;
      afterFadeIn = (function(_this) {
        return function() {
          return setTimeout(afterDelay, _this.delay * 5 / 6);
        };
      })(this);
      afterDelay = (function(_this) {
        return function() {
          return _this.message.fadeOut(_this.delay / 6);
        };
      })(this);
      this.message = skill.getMessageEl();
      this.message.addClass('blue-box').appendTo(this.container);
      return this.message.hide().fadeIn(this.delay / 6, afterFadeIn);
    };

    Battle.prototype.encounterDone = function() {
      var item, pu;
      Battle.__super__.encounterDone.call(this, false);
      pu = this.getPlayerUnit();
      if ((pu.equipped != null) && pu.equipped.uses === 0) {
        item = pu.equipped;
        pu.inventory.remove(item);
        return this.ui.messageBox.showBrokenMessage(item, this.afterWeaponBreak);
      } else {
        return this.afterWeaponBreak();
      }
    };

    Battle.prototype.afterWeaponBreak = function() {
      var doDrop, eu, item, pu, _i, _len, _ref;
      pu = this.getPlayerUnit();
      eu = this.getEnemyUnit();
      doDrop = false;
      if (eu.hp === 0) {
        _ref = eu.inventory.it();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (item.drop) {
            eu.inventory.remove(item);
            doDrop = true;
            this.ui.staticTurn.doReceiveItem(pu, item, this.afterWeaponBreak);
            break;
          }
        }
      }
      if (!doDrop) {
        return this.afterReceiveItem();
      }
    };

    Battle.prototype.afterReceiveItem = function() {
      var keepGoing;
      keepGoing = true;
      if (this.atk.hp === 0) {
        keepGoing = this.ui.chapter.kill(this.atk);
      }
      if (this.def.hp === 0) {
        keepGoing = this.ui.chapter.kill(this.def);
      }
      if (keepGoing) {
        return this.callback();
      }
    };

    Battle.prototype.getExpToAdd = function() {
      var ceil, defeatExp, dmgExp, enemy, exp, levelDif, player;
      player = this.getPlayerUnit();
      enemy = this.getEnemyUnit();
      levelDif = enemy.level - player.level;
      if (this.attacksHit > 0) {
        dmgExp = .10 + levelDif / 100;
      } else {
        dmgExp = .01;
      }
      defeatExp = 0;
      if (enemy.hp === 0) {
        defeatExp = .25 + levelDif / 100;
        if (enemy.boss) {
          defeatExp += .4;
        }
      }
      exp = dmgExp + defeatExp;
      exp *= ui.expMultiplier;
      if (exp > 1) {
        ceil = 1;
      } else {
        ceil = exp;
      }
      return ceil;
    };

    Battle.prototype.displayMessage = function(overUnit, mtype) {
      var el, left, startFadeOut, top, tw;
      el = $('<div class="battle-message"></div>');
      el.addClass(mtype);
      tw = this.ui.tw;
      if (mtype === 'miss') {
        el.text('MISS');
      } else if (mtype === 'crit') {
        el.text('CRIT!');
      } else if (mtype === 'no-dmg') {
        el.text('NO DMG');
      }
      top = overUnit.pos.i * tw - ui.origin.i;
      left = overUnit.pos.j * tw + tw / 2 - el.width() / 2 - ui.origin.j;
      el.appendTo($('.canvas-container')).css({
        top: top,
        left: left
      });
      el.fadeIn(this.delay / 5);
      startFadeOut = (function(_this) {
        return function() {
          el.fadeOut(_this.delay / 5);
          return el.remove();
        };
      })(this);
      return setTimeout(startFadeOut, 3 * this.delay / 5);
    };

    return Battle;

  })(_enc.Encounter);

}).call(this);
