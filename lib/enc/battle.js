// Generated by CoffeeScript 1.12.2
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _enc.Battle = (function(superClass) {
    extend(Battle, superClass);

    function Battle(ui1, atk, def, dist) {
      this.ui = ui1;
      this.atk = atk;
      this.def = def;
      this.dist = dist != null ? dist : null;
      this.afterReceiveItem = bind(this.afterReceiveItem, this);
      this.afterWeaponBreak = bind(this.afterWeaponBreak, this);
      this.encounterDone = bind(this.encounterDone, this);
      this.doAction = bind(this.doAction, this);
      if (this.dist == null) {
        this.dist = this.atk.pos.distance(this.def.pos);
      }
      this.mpTaken = false;
      this.statusInflicted = false;
      this.skillMessageShown = false;
      this.atk.calcCombatStats();
      this.def.calcCombatStats();
      this.calcBattleStats();
    }

    Battle.prototype.calcBattleStats = function() {
      var defCanAttack, i, j, k, l, len, m, n, ref, ref1, ref2, ref3, ref4, unit;
      this.atk.advantage = null;
      this.def.advantage = null;
      this.calcAdvantage(this.atk, this.def);
      this.calcAdvantage(this.def, this.atk);
      this.calcIndividual(this.atk, this.def);
      this.calcIndividual(this.def, this.atk);
      this.turns = [];
      for (i = j = 1, ref = this.atk.equipped.nAttackMultiplier; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        this.turns.push(this.atk);
      }
      defCanAttack = (this.def.equipped != null) && this.def.equipped.range.contains(this.dist) && !this.def.hasStatus(_status.Defend);
      if (defCanAttack) {
        for (i = k = 1, ref1 = this.def.equipped.nAttackMultiplier; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
          this.turns.push(this.def);
        }
      }
      if (this.atk.attackSpeed - 4 > this.def.attackSpeed && this.atk.equipped.hasUses(2)) {
        for (i = l = 1, ref2 = this.atk.equipped.nAttackMultiplier; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {
          this.turns.push(this.atk);
        }
      } else if (defCanAttack && this.def.attackSpeed - 4 > this.atk.attackSpeed && this.def.equipped.hasUses(2)) {
        for (i = m = 1, ref3 = this.def.equipped.nAttackMultiplier; 1 <= ref3 ? m <= ref3 : m >= ref3; i = 1 <= ref3 ? ++m : --m) {
          this.turns.push(this.def);
        }
      }
      this.nTurns = {
        atk: 0,
        def: 0
      };
      ref4 = this.turns;
      for (n = 0, len = ref4.length; n < len; n++) {
        unit = ref4[n];
        if (unit === this.atk) {
          this.nTurns.atk++;
        } else {
          this.nTurns.def++;
        }
      }
      return this.attacksHit = 0;
    };

    Battle.prototype.calcAdvantage = function(unit1, unit2) {
      var Axe, Lance, Sword, t1, t2;
      if (!((unit1.equipped != null) && (unit2.equipped != null))) {
        return;
      }
      t1 = unit1.equipped.type;
      t2 = unit2.equipped.type;
      Sword = _skill.type.Sword;
      Lance = _skill.type.Lance;
      Axe = _skill.type.Axe;
      if ((t1 instanceof Sword && t2 instanceof Axe) || (t1 instanceof Axe && t2 instanceof Lance) || (t1 instanceof Lance && t2 instanceof Sword)) {
        unit1.advantage = true;
        return unit2.advantage = false;
      }
    };

    Battle.prototype.calcIndividual = function(unit1, unit2) {
      var defOrRes, factor, key, ref, results, strOrMag, value, w1;
      w1 = unit1.equipped;
      if (w1 == null) {
        return;
      }
      unit1.battleStats = {};
      if (!w1.range.contains(this.dist)) {
        return;
      }
      if (w1.type instanceof _skill.type.Physical) {
        strOrMag = unit1.str;
        defOrRes = unit2.def + unit2.defResBonus;
      } else if (w1.type instanceof _skill.type.Magic) {
        strOrMag = unit1.mag;
        defOrRes = unit2.res + unit2.defResBonus;
      }
      unit1.battleStats.hit = unit1.hit - unit2.evade;
      unit1.battleStats.dmg = strOrMag + w1.might - defOrRes;
      unit1.battleStats.crt = unit1.crit - unit2.critEvade;
      if (unit1.advantage === true) {
        factor = 1;
      } else if (unit1.advantage === false) {
        factor = -1;
      } else {
        factor = 0;
      }
      unit1.battleStats.hit += factor * 15;
      unit1.battleStats.dmg += factor * 1;
      if (unit2.hasStatus(_status.Defend)) {
        unit1.battleStats.dmg = Math.round(unit1.battleStats.dmg / 2);
      }
      ref = unit1.battleStats;
      results = [];
      for (key in ref) {
        value = ref[key];
        if (value < 0) {
          unit1.battleStats[key] = 0;
        }
        if ((key === 'hit' || key === 'crt') && value > 100) {
          results.push(unit1.battleStats[key] = 100);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Battle.prototype.getPlayerUnit = function() {
      if (this.atk.team instanceof _team.PlayerTeam) {
        return this.atk;
      } else {
        return this.def;
      }
    };

    Battle.prototype.getEnemyUnit = function() {
      return this.getOther(this.getPlayerUnit());
    };

    Battle.prototype.doAction = function() {
      var callMade, data, dmg, giver, randCrit, randHit, recvr;
      callMade = false;
      giver = this.turns[this.turnIndex];
      recvr = this.getOther(giver);
      this.doLunge(giver);
      if (giver.equipped.mp != null) {
        if (!this.mpTaken) {
          giver.mp -= giver.equipped.mp;
          this.mpTaken = true;
        }
      }
      if ((giver.equipped.getMessageEl != null) && !this.skillMessageShown) {
        this.showSkillMessage(giver.equipped);
      }
      randHit = 100 * Math.random();
      if (randHit < giver.battleStats.hit) {
        dmg = giver.battleStats.dmg;
        randCrit = 100 * Math.random();
        if (randCrit < giver.battleStats.crt) {
          this.displayMessage(recvr, 'crit');
          dmg *= 3;
        }
        recvr.hp -= dmg;
        if (dmg === 0) {
          this.displayMessage(recvr, 'no-dmg');
        }
        if (giver === this.getPlayerUnit()) {
          if ((giver.equipped.mp == null) && giver.mp < giver.maxMp) {
            giver.mp++;
            if (giver.equipped.uses != null) {
              giver.equipped.uses--;
            }
          }
          this.attacksHit++;
        }
        if ((giver.equipped.getStatusEffect != null) && !this.statusInflicted) {
          data = {
            battle: this
          };
          recvr.addStatus(giver.equipped.getStatusEffect(data));
          this.statusInflicted = true;
        }
      } else {
        this.displayMessage(recvr, 'miss');
      }
      if (recvr.hp <= 0) {
        recvr.hp = 0;
        setTimeout(this.encounterDone, this.delay);
        callMade = true;
      }
      this.turnIndex++;
      if (!callMade) {
        if (this.turnIndex === this.turns.length) {
          setTimeout(this.encounterDone, this.delay);
        } else {
          setTimeout(this.doAction, this.delay);
        }
      }
      this.atkBox.init(this.atk, true);
      return this.defBox.init(this.def, true);
    };

    Battle.prototype.showSkillMessage = function(skill) {
      var afterDelay, afterFadeIn;
      afterFadeIn = (function(_this) {
        return function() {
          return setTimeout(afterDelay, _this.delay * 5 / 6);
        };
      })(this);
      afterDelay = (function(_this) {
        return function() {
          return _this.message.fadeOut(_this.delay / 6);
        };
      })(this);
      this.skillMessageShown = true;
      this.message = skill.getMessageEl();
      this.message.addClass('blue-box').appendTo(this.container);
      return this.message.hide().fadeIn(this.delay / 6, afterFadeIn);
    };

    Battle.prototype.encounterDone = function() {
      var item, pu;
      Battle.__super__.encounterDone.call(this, false);
      pu = this.getPlayerUnit();
      if ((pu.equipped != null) && (pu.equipped.uses != null) && pu.equipped.uses <= 0) {
        item = pu.equipped;
        pu.inventory.remove(item);
        return this.ui.messageBox.showBrokenMessage(item, this.afterWeaponBreak);
      } else {
        return this.afterWeaponBreak();
      }
    };

    Battle.prototype.afterWeaponBreak = function() {
      var doDrop, eu, item, j, len, pu, ref;
      pu = this.getPlayerUnit();
      eu = this.getEnemyUnit();
      doDrop = false;
      if (eu.hp === 0) {
        ref = eu.inventory.it();
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          if (item.drop) {
            eu.inventory.remove(item);
            doDrop = true;
            this.ui.staticTurn.doReceiveItem(pu, item, this.afterWeaponBreak);
            break;
          }
        }
      }
      if (!doDrop) {
        return this.afterReceiveItem();
      }
    };

    Battle.prototype.afterReceiveItem = function() {
      var keepGoing;
      keepGoing = true;
      if (this.atk.hp === 0) {
        keepGoing = this.ui.chapter.kill(this.atk);
      }
      if (this.def.hp === 0) {
        keepGoing = this.ui.chapter.kill(this.def);
      }
      if (keepGoing) {
        return this.callback();
      }
    };

    Battle.prototype.getExpToAdd = function() {
      var ceil, defeatExp, dmgExp, enemy, exp, levelDif, player;
      player = this.getPlayerUnit();
      enemy = this.getEnemyUnit();
      levelDif = enemy.level - player.level;
      if (this.attacksHit > 0) {
        dmgExp = .10 + levelDif / 100;
        if (dmgExp <= .05) {
          dmgExp = .05;
        }
      } else {
        dmgExp = .01;
      }
      defeatExp = 0;
      if (enemy.hp === 0) {
        defeatExp = .25 + levelDif / 100;
        if (defeatExp < 0) {
          defeatExp = .1;
        }
        if (enemy.boss) {
          defeatExp += .4;
        }
      }
      exp = dmgExp + defeatExp;
      exp *= ui.expMultiplier;
      if (exp > 1) {
        ceil = 1;
      } else {
        ceil = exp;
      }
      return ceil;
    };

    Battle.prototype.displayMessage = function(overUnit, mtype) {
      var el, left, startFadeOut, top, tw;
      el = $('<div class="battle-message"></div>');
      el.addClass(mtype);
      tw = this.ui.tw;
      if (mtype === 'miss') {
        el.text('MISS');
      } else if (mtype === 'crit') {
        el.text('CRIT!');
      } else if (mtype === 'no-dmg') {
        el.text('NO DMG');
      }
      top = overUnit.pos.i * tw - ui.origin.i;
      left = overUnit.pos.j * tw + tw / 2 - el.width() / 2 - ui.origin.j;
      el.appendTo($('.canvas-container')).css({
        top: top,
        left: left
      });
      el.fadeIn(this.delay / 5);
      startFadeOut = (function(_this) {
        return function() {
          el.fadeOut(_this.delay / 5);
          return el.remove();
        };
      })(this);
      return setTimeout(startFadeOut, 3 * this.delay / 5);
    };

    return Battle;

  })(_enc.Encounter);

}).call(this);
