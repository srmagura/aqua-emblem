// Generated by CoffeeScript 1.12.2
(function() {
  var getRandomPermutation,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  getRandomPermutation = function(k) {
    var i, l, m, perm, r, ref, ref1, results, todo;
    todo = (function() {
      results = [];
      for (var l = 0, ref = k - 1; 0 <= ref ? l <= ref : l >= ref; 0 <= ref ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this);
    perm = [];
    while (todo.length !== 0) {
      r = Math.random();
      for (i = m = 0, ref1 = todo.length - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
        if (r < (i + 1) / todo.length) {
          perm.push(todo.splice(i, 1)[0]);
          break;
        }
      }
    }
    return perm;
  };

  window._turn = {};

  _turn.Turn = (function() {
    function Turn(ui1) {
      this.ui = ui1;
      this.afterBattle = bind(this.afterBattle, this);
      this.directions = [new Position(-1, 0), new Position(1, 0), new Position(0, -1), new Position(0, 1)];
    }

    Turn.prototype.getAvailable = function(unit, options) {
      var alt, available, dest, dist, i, j, k, l, len, m, map, n, noLimit, perm, popClosest, pos, pos2, posDist, prev, prevPos, queue, queuePerm, ref, ref1, ref2, unitAt;
      if (options == null) {
        options = {};
      }
      if ('noLimit' in options && options.noLimit) {
        noLimit = true;
      } else {
        noLimit = false;
      }
      map = this.ui.chapter.map;
      available = [new _map.Destination(unit.pos, [unit.pos])];
      queue = [];
      queuePerm = getRandomPermutation(map.width * map.height);
      dist = Array(map.height);
      prev = Array(map.height);
      k = 0;
      for (i = l = 0, ref = map.height - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
        dist[i] = Array(map.width);
        prev[i] = Array(map.width);
        for (j = m = 0, ref1 = map.width - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
          dist[i][j] = 2e308;
          prev[i][j] = null;
          queue[queuePerm[k]] = new Position(i, j);
          k++;
        }
      }
      dist[unit.pos.i][unit.pos.j] = 0;
      popClosest = function() {
        var alt, len, minDist, minDistK, n, pos2;
        minDist = 2e308;
        for (k = n = 0, len = queue.length; n < len; k = ++n) {
          pos2 = queue[k];
          alt = dist[pos2.i][pos2.j];
          if (alt < minDist) {
            minDist = alt;
            minDistK = k;
          }
        }
        return [queue.splice(minDistK, 1)[0], minDist];
      };
      while (queue.length !== 0) {
        ref2 = popClosest(), pos = ref2[0], posDist = ref2[1];
        if (posDist === 2e308) {
          break;
        }
        perm = getRandomPermutation(this.directions.length);
        for (n = 0, len = perm.length; n < len; n++) {
          k = perm[n];
          pos2 = pos.add(this.directions[k]);
          unitAt = this.ui.chapter.getUnitAt(pos2);
          if (map.onMap(pos2) && !map.tiles[pos2.i][pos2.j].block) {
            alt = posDist + 1;
            if ((unitAt === null || unitAt.team === unit.team) && alt < dist[pos2.i][pos2.j] && (noLimit || alt <= unit.move)) {
              dist[pos2.i][pos2.j] = alt;
              prev[pos2.i][pos2.j] = pos;
              dest = new _map.Destination(pos2, [pos2]);
              prevPos = pos;
              while (prevPos !== null) {
                dest.path.unshift(prevPos);
                prevPos = prev[prevPos.i][prevPos.j];
              }
              available.push(dest);
            }
          }
        }
      }
      return available;
    };

    Turn.prototype.getDirections = function(totalRange) {
      var di, dirs, dj, l, len, m, n, range, ref, ref1, ref2, ref3, ref4;
      dirs = [];
      ref = totalRange.array;
      for (l = 0, len = ref.length; l < len; l++) {
        range = ref[l];
        for (di = m = ref1 = -range, ref2 = range; ref1 <= ref2 ? m <= ref2 : m >= ref2; di = ref1 <= ref2 ? ++m : --m) {
          for (dj = n = ref3 = -range, ref4 = range; ref3 <= ref4 ? n <= ref4 : n >= ref4; dj = ref3 <= ref4 ? ++n : --n) {
            if (Math.abs(di) + Math.abs(dj) === range) {
              dirs.push(new Position(di, dj));
            }
          }
        }
      }
      return dirs;
    };

    Turn.prototype.getAttackRange = function(unit, pos) {
      var alt, attackRange, dir, l, len, ref;
      attackRange = [];
      ref = this.getDirections(unit.totalRange);
      for (l = 0, len = ref.length; l < len; l++) {
        dir = ref[l];
        alt = pos.add(dir);
        if (this.ui.chapter.map.onMap(alt)) {
          attackRange.push({
            moveSpot: pos,
            targetSpot: alt
          });
        }
      }
      return attackRange;
    };

    Turn.prototype.getActionRange = function(pos, range) {
      var actionRange, alt, dir, l, len, ref;
      actionRange = [];
      ref = this.getDirections(range);
      for (l = 0, len = ref.length; l < len; l++) {
        dir = ref[l];
        alt = pos.add(dir);
        if (this.ui.chapter.map.onMap(alt)) {
          actionRange.push(alt);
        }
      }
      return actionRange;
    };

    Turn.prototype.movementGetAttackRange = function(available, unit) {
      var attackRange, avail, l, len, len1, localRange, m, obj;
      attackRange = [];
      for (l = 0, len = available.length; l < len; l++) {
        avail = available[l];
        localRange = this.getAttackRange(unit, avail.pos);
        for (m = 0, len1 = localRange.length; m < len1; m++) {
          obj = localRange[m];
          obj.path = avail.path;
          attackRange.push(obj);
        }
      }
      return attackRange;
    };

    Turn.prototype.doReceiveItem = function(unit, item, callback) {
      var afterMessage;
      afterMessage = (function(_this) {
        return function() {
          unit.inventory.push(item);
          if (unit.inventory.size() <= _unit.Inventory.MAX_SIZE) {
            return callback();
          } else {
            _this.ui.unitInfoBox.init(unit, false, true);
            return _this.ui.itemMenu.init({
              forceDiscard: true,
              callback: (function() {
                _this.ui.unitInfoBox.hide();
                return callback();
              }),
              unit: unit
            });
          }
        };
      })(this);
      item = new item.constructor();
      return this.ui.messageBox.showReceivedMessage(unit, item, afterMessage);
    };

    Turn.prototype.afterBattle = function() {
      var playerUnit, toAdd;
      toAdd = this.battle.getExpToAdd();
      playerUnit = this.battle.getPlayerUnit();
      return _turn.addExp(this.ui, this.afterExpAdd, playerUnit, toAdd);
    };

    return Turn;

  })();

  _turn.addExp = function(ui, afterExpAdd, playerUnit, toAdd) {
    var callback, callback2, increment;
    increment = null;
    callback = (function(_this) {
      return function() {
        increment = playerUnit.addExp(toAdd);
        if (increment === null) {
          return afterExpAdd();
        } else {
          return ui.levelUpWindow.init(playerUnit, increment, callback2);
        }
      };
    })(this);
    callback2 = (function(_this) {
      return function() {
        playerUnit.doIncrement(increment);
        return afterExpAdd();
      };
    })(this);
    return ui.expBar.init(playerUnit, toAdd, callback);
  };

}).call(this);
