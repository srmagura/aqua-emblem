// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _turn.EnemyTurn = (function(_super) {
    __extends(EnemyTurn, _super);

    function EnemyTurn() {
      this.afterExpAdd = __bind(this.afterExpAdd, this);
      return EnemyTurn.__super__.constructor.apply(this, arguments);
    }

    EnemyTurn.prototype.doTurn = function() {
      var eu;
      eu = this.ui.chapter.enemyTeam.units;
      if (eu.length !== 0) {
        return this.doUnitTurn(eu[0]);
      }
    };

    EnemyTurn.prototype.doUnitTurn = function(unit) {
      var afterScroll, attackRange, avail, available, available0, eu, inRange, obj, selectedInRange, unit1, unit2, unitAt, _i, _j, _len, _len1;
      if (unit == null) {
        this.ui.chapter.initTurn(this.ui.chapter.playerTeam);
        return;
      }
      eu = this.ui.chapter.enemyTeam.units;
      this.nextUnit = eu[eu.indexOf(unit) + 1];
      if (unit.aiType === _unit.AI_TYPE.HALT) {
        available = [new _turn.Destination(unit.pos, [unit.pos])];
      } else {
        available0 = this.getAvailable(unit);
        available = [];
        for (_i = 0, _len = available0.length; _i < _len; _i++) {
          avail = available0[_i];
          unitAt = this.ui.chapter.getUnitAt(avail.pos);
          if (unitAt === null || unitAt === unit) {
            available.push(avail);
          }
        }
      }
      attackRange = this.movementGetAttackRange(available, unit);
      inRange = [];
      for (_j = 0, _len1 = attackRange.length; _j < _len1; _j++) {
        obj = attackRange[_j];
        unit1 = this.ui.chapter.getUnitAt(obj.targetSpot);
        unit2 = this.ui.chapter.getUnitAt(obj.moveSpot);
        if ((unit2 === null || unit2 === unit) && unit1 !== null && unit1.team === this.ui.chapter.playerTeam) {
          inRange.push({
            moveSpot: obj.moveSpot,
            path: obj.path,
            target: unit1
          });
        }
      }
      afterScroll = (function(_this) {
        return function() {
          var moveSpot, target;
          target = selectedInRange.target;
          moveSpot = selectedInRange.moveSpot;
          if (!_this.ui.onScreen(moveSpot) || !_this.ui.onScreen(target.pos)) {
            _this.ui.scrollTo(moveSpot, function() {});
          }
          return unit.followPath(selectedInRange.path, function() {
            _this.battle = new _enc.Battle(_this.ui, unit, target);
            return _this.battle.doEncounter(_this.afterBattle);
          });
        };
      })(this);
      if (inRange.length !== 0) {
        selectedInRange = this.chooseTarget(unit, inRange);
        if (!this.ui.onScreen(unit.pos)) {
          return this.ui.scrollTo(unit.pos, afterScroll);
        } else {
          return afterScroll();
        }
      } else {
        return this.doUnitTurn(this.nextUnit);
      }
    };

    EnemyTurn.prototype.afterExpAdd = function() {
      return setTimeout(((function(_this) {
        return function() {
          return _this.doUnitTurn(_this.nextUnit);
        };
      })(this)), 250 / this.ui.speedMultiplier);
    };

    EnemyTurn.prototype.chooseMaxDmg = function(list) {
      var max, maxObj, obj, _i, _len;
      max = -1;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        obj = list[_i];
        if (obj.maxDmg > max) {
          max = obj.maxDmg;
          maxObj = obj;
        }
      }
      return maxObj;
    };

    EnemyTurn.prototype.chooseTarget = function(enemy, inRange) {
      var battle, noRetaliate, obj, range, target, _i, _len;
      noRetaliate = [];
      for (_i = 0, _len = inRange.length; _i < _len; _i++) {
        obj = inRange[_i];
        target = obj.target;
        range = obj.moveSpot.distance(target.pos);
        battle = new _enc.Battle(this.ui, enemy, target, range);
        obj.maxDmg = battle.nTurns.atk * enemy.battleStats.dmg;
        if (obj.maxDmg >= target.hp) {
          return obj;
        }
        if (battle.nTurns.def === 0) {
          noRetaliate.push(obj);
        }
      }
      if (noRetaliate.length !== 0) {
        return this.chooseMaxDmg(noRetaliate);
      }
      return this.chooseMaxDmg(inRange);
    };

    return EnemyTurn;

  })(_turn.Turn);

}).call(this);
