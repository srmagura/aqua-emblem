// Generated by CoffeeScript 1.12.2
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _turn.EnemyTurn = (function(superClass) {
    extend(EnemyTurn, superClass);

    function EnemyTurn() {
      this.afterExpAdd = bind(this.afterExpAdd, this);
      return EnemyTurn.__super__.constructor.apply(this, arguments);
    }

    EnemyTurn.prototype.doTurn = function() {
      var eu;
      this.team = this.ui.chapter.enemyTeam;
      eu = this.team.units;
      return this.doUnitTurn(eu[0]);
    };

    EnemyTurn.prototype.doUnitTurn = function(unit) {
      var afterMove, afterScroll, attackRange, avail, available, available0, eu, inRange, j, k, len, len1, obj, selectedInRange, unit1, unit2, unitAt;
      if (unit == null) {
        this.spawnReinforcements();
        return;
      }
      eu = this.team.units;
      this.nextUnit = eu[eu.indexOf(unit) + 1];
      if (unit.aiType === _unit.aiType.halt) {
        available = [new _map.Destination(unit.pos, [unit.pos])];
      } else {
        available0 = this.getAvailable(unit);
        available = [];
        for (j = 0, len = available0.length; j < len; j++) {
          avail = available0[j];
          unitAt = this.ui.chapter.getUnitAt(avail.pos);
          if (unitAt === null || unitAt === unit) {
            available.push(avail);
          }
        }
      }
      attackRange = this.movementGetAttackRange(available, unit);
      inRange = [];
      for (k = 0, len1 = attackRange.length; k < len1; k++) {
        obj = attackRange[k];
        unit1 = this.ui.chapter.getUnitAt(obj.targetSpot);
        unit2 = this.ui.chapter.getUnitAt(obj.moveSpot);
        if ((unit2 === null || unit2 === unit) && unit1 !== null && unit1.team === this.ui.chapter.playerTeam) {
          inRange.push({
            moveSpot: obj.moveSpot,
            path: obj.path,
            target: unit1
          });
        }
      }
      afterScroll = (function(_this) {
        return function() {
          var moveSpot, target;
          target = selectedInRange.target;
          moveSpot = selectedInRange.moveSpot;
          if (!_this.ui.onScreen(moveSpot) || !_this.ui.onScreen(target.pos)) {
            _this.ui.scrollTo(moveSpot, function() {
              _this.scrollToMoveSpotDone = true;
              return afterMove();
            });
          } else {
            _this.scrollToMoveSpotDone = true;
          }
          _this.battle = new _enc.Battle(_this.ui, unit, target, moveSpot.distance(target.pos));
          return unit.followPath(selectedInRange.path, function() {
            _this.followPathDone = true;
            return afterMove();
          });
        };
      })(this);
      this.scrollToMoveSpotDone = false;
      this.followPathDone = false;
      afterMove = (function(_this) {
        return function() {
          if (_this.scrollToMoveSpotDone && _this.followPathDone) {
            return _this.battle.doEncounter(_this.afterBattle);
          }
        };
      })(this);
      if (inRange.length !== 0) {
        selectedInRange = this.chooseTarget(unit, inRange);
        if (!this.ui.onScreen(unit.pos)) {
          return this.ui.scrollTo(unit.pos, afterScroll);
        } else {
          return afterScroll();
        }
      } else {
        if (unit.aiType === _unit.aiType.aggressive && (!('startTurn' in unit.aiOptions) || this.ui.chapter.turnIndex >= unit.aiOptions.startTurn)) {
          return this.doAdvance(unit);
        } else {
          return this.doUnitTurn(this.nextUnit);
        }
      }
    };

    EnemyTurn.prototype.afterExpAdd = function() {
      return setTimeout(((function(_this) {
        return function() {
          return _this.doUnitTurn(_this.nextUnit);
        };
      })(this)), 250 / this.ui.speedMultiplier);
    };

    EnemyTurn.prototype.chooseMaxDmg = function(list) {
      var j, len, max, maxObj, obj;
      max = -1;
      for (j = 0, len = list.length; j < len; j++) {
        obj = list[j];
        if (obj.maxDmg > max) {
          max = obj.maxDmg;
          maxObj = obj;
        }
      }
      return maxObj;
    };

    EnemyTurn.prototype.chooseTarget = function(enemy, inRange) {
      var battle, j, len, noRetaliate, obj, range, target;
      noRetaliate = [];
      for (j = 0, len = inRange.length; j < len; j++) {
        obj = inRange[j];
        target = obj.target;
        range = obj.moveSpot.distance(target.pos);
        battle = new _enc.Battle(this.ui, enemy, target, range);
        obj.maxDmg = battle.nTurns.atk * enemy.battleStats.dmg;
        if (obj.maxDmg >= target.hp) {
          return obj;
        }
        if (battle.nTurns.def === 0) {
          noRetaliate.push(obj);
        }
      }
      if (noRetaliate.length !== 0) {
        return this.chooseMaxDmg(noRetaliate);
      }
      return this.chooseMaxDmg(inRange);
    };

    EnemyTurn.prototype.doAdvance = function(unit) {
      var afterScroll, attackRange, available, dist, fullPath, i, j, len, minDist, moveSpot, obj, path, target, unitAt;
      available = this.getAvailable(unit, {
        noLimit: true
      });
      attackRange = this.movementGetAttackRange(available, unit);
      minDist = 2e308;
      for (j = 0, len = attackRange.length; j < len; j++) {
        obj = attackRange[j];
        dist = unit.pos.distance(obj.moveSpot);
        target = this.ui.chapter.getUnitAt(obj.targetSpot);
        if ((target != null) && target.team instanceof _team.PlayerTeam && dist < minDist) {
          fullPath = obj.path;
          minDist = dist;
        }
      }
      if (fullPath.length - 1 < unit.move) {
        i = fullPath.length - 1;
      } else {
        i = unit.move;
      }
      while (true) {
        moveSpot = fullPath[i];
        path = fullPath.slice(0, i + 1);
        i--;
        unitAt = this.ui.chapter.getUnitAt(moveSpot);
        if (unitAt == null) {
          break;
        }
        if (i < 0) {
          this.doUnitTurn(this.nextUnit);
          return;
        }
      }
      afterScroll = (function(_this) {
        return function() {
          if (!_this.ui.onScreen(moveSpot)) {
            _this.ui.scrollTo(moveSpot, function() {});
          }
          return unit.followPath(path, function() {
            return _this.doUnitTurn(_this.nextUnit);
          });
        };
      })(this);
      if (!this.ui.onScreen(unit.pos)) {
        return this.ui.scrollTo(unit.pos, afterScroll);
      } else {
        return afterScroll();
      }
    };

    EnemyTurn.prototype.spawnUnit = function(toAdd, i) {
      var afterScroll, unit;
      if (i === toAdd.length) {
        this.doStatus();
        return;
      }
      unit = toAdd[i];
      if (this.ui.chapter.getUnitAt(unit.pos) != null) {
        this.spawnUnit(toAdd, i + 1);
        return;
      }
      afterScroll = (function(_this) {
        return function() {
          _this.ui.chapter.addUnit(_this.team, unit);
          return setTimeout((function() {
            return _this.spawnUnit(toAdd, i + 1);
          }), 750 / _this.ui.speedMultiplier);
        };
      })(this);
      if (!this.ui.onScreen(unit.pos)) {
        return this.ui.scrollTo(unit.pos, afterScroll);
      } else {
        return afterScroll();
      }
    };

    EnemyTurn.prototype.spawnReinforcements = function() {
      var j, len, ref, toAdd, turnIndex, unit;
      toAdd = [];
      turnIndex = this.ui.chapter.turnIndex;
      ref = this.team.reinforcements;
      for (j = 0, len = ref.length; j < len; j++) {
        unit = ref[j];
        if (unit.spawnTurn === turnIndex) {
          unit.ui = this.ui;
          toAdd.push(unit);
        }
      }
      return this.spawnUnit(toAdd, 0);
    };

    EnemyTurn.prototype.doStatus = function() {
      var callback, doPoison, i, j, len, poisoned, ref, unit;
      poisoned = [];
      ref = this.team.units;
      for (j = 0, len = ref.length; j < len; j++) {
        unit = ref[j];
        if (unit.hasStatus(_status.Poison)) {
          poisoned.push(unit);
        }
      }
      i = 0;
      unit = null;
      callback = (function(_this) {
        return function() {
          var keepGoing;
          keepGoing = true;
          if (unit.hp === 0) {
            keepGoing = _this.ui.chapter.kill(unit);
          }
          if (keepGoing) {
            i++;
            return doPoison();
          }
        };
      })(this);
      doPoison = (function(_this) {
        return function() {
          var action, delta, unitAction;
          if (i === poisoned.length) {
            _this.calcCombatStats();
            return;
          }
          unit = poisoned[i];
          action = new _status.PoisonAction();
          delta = {
            hp: -unit.getStatus(_status.Poison).dmg
          };
          unitAction = new _enc.UnitAction(_this.ui, unit);
          return unitAction.doAction(action, callback, delta);
        };
      })(this);
      return doPoison();
    };

    EnemyTurn.prototype.calcCombatStats = function() {
      var j, len, ref, unit;
      ref = this.team.units;
      for (j = 0, len = ref.length; j < len; j++) {
        unit = ref[j];
        unit.calcCombatStats();
      }
      return this.ui.chapter.initTurn(this.ui.chapter.playerTeam);
    };

    return EnemyTurn;

  })(_turn.Turn);

}).call(this);
