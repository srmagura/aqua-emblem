// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _turn.EnemyTurn = (function(_super) {
    __extends(EnemyTurn, _super);

    function EnemyTurn() {
      this.afterExpAdd = __bind(this.afterExpAdd, this);
      return EnemyTurn.__super__.constructor.apply(this, arguments);
    }

    EnemyTurn.prototype.doTurn = function() {
      var eu;
      this.team = this.ui.chapter.enemyTeam;
      eu = this.team.units;
      return this.doUnitTurn(eu[0]);
    };

    EnemyTurn.prototype.doUnitTurn = function(unit) {
      var afterMove, afterScroll, attackRange, avail, available, available0, eu, inRange, obj, selectedInRange, unit1, unit2, unitAt, _i, _j, _len, _len1;
      if (unit == null) {
        this.spawnReinforcements();
        return;
      }
      eu = this.team.units;
      this.nextUnit = eu[eu.indexOf(unit) + 1];
      if (unit.aiType === _unit.aiType.halt) {
        available = [new _map.Destination(unit.pos, [unit.pos])];
      } else {
        available0 = this.getAvailable(unit);
        available = [];
        for (_i = 0, _len = available0.length; _i < _len; _i++) {
          avail = available0[_i];
          unitAt = this.ui.chapter.getUnitAt(avail.pos);
          if (unitAt === null || unitAt === unit) {
            available.push(avail);
          }
        }
      }
      attackRange = this.movementGetAttackRange(available, unit);
      inRange = [];
      for (_j = 0, _len1 = attackRange.length; _j < _len1; _j++) {
        obj = attackRange[_j];
        unit1 = this.ui.chapter.getUnitAt(obj.targetSpot);
        unit2 = this.ui.chapter.getUnitAt(obj.moveSpot);
        if ((unit2 === null || unit2 === unit) && unit1 !== null && unit1.team === this.ui.chapter.playerTeam) {
          inRange.push({
            moveSpot: obj.moveSpot,
            path: obj.path,
            target: unit1
          });
        }
      }
      afterScroll = (function(_this) {
        return function() {
          var moveSpot, target;
          target = selectedInRange.target;
          moveSpot = selectedInRange.moveSpot;
          if (!_this.ui.onScreen(moveSpot) || !_this.ui.onScreen(target.pos)) {
            _this.ui.scrollTo(moveSpot, function() {
              _this.scrollToMoveSpotDone = true;
              return afterMove();
            });
          } else {
            _this.scrollToMoveSpotDone = true;
          }
          _this.battle = new _enc.Battle(_this.ui, unit, target, moveSpot.distance(target.pos));
          return unit.followPath(selectedInRange.path, function() {
            _this.followPathDone = true;
            return afterMove();
          });
        };
      })(this);
      this.scrollToMoveSpotDone = false;
      this.followPathDone = false;
      afterMove = (function(_this) {
        return function() {
          if (_this.scrollToMoveSpotDone && _this.followPathDone) {
            return _this.battle.doEncounter(_this.afterBattle);
          }
        };
      })(this);
      if (inRange.length !== 0) {
        selectedInRange = this.chooseTarget(unit, inRange);
        if (!this.ui.onScreen(unit.pos)) {
          return this.ui.scrollTo(unit.pos, afterScroll);
        } else {
          return afterScroll();
        }
      } else {
        if (unit.aiType === _unit.aiType.aggressive) {
          return this.doAdvance(unit);
        } else {
          return this.doUnitTurn(this.nextUnit);
        }
      }
    };

    EnemyTurn.prototype.afterExpAdd = function() {
      return setTimeout(((function(_this) {
        return function() {
          return _this.doUnitTurn(_this.nextUnit);
        };
      })(this)), 250 / this.ui.speedMultiplier);
    };

    EnemyTurn.prototype.chooseMaxDmg = function(list) {
      var max, maxObj, obj, _i, _len;
      max = -1;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        obj = list[_i];
        if (obj.maxDmg > max) {
          max = obj.maxDmg;
          maxObj = obj;
        }
      }
      return maxObj;
    };

    EnemyTurn.prototype.chooseTarget = function(enemy, inRange) {
      var battle, noRetaliate, obj, range, target, _i, _len;
      noRetaliate = [];
      for (_i = 0, _len = inRange.length; _i < _len; _i++) {
        obj = inRange[_i];
        target = obj.target;
        range = obj.moveSpot.distance(target.pos);
        battle = new _enc.Battle(this.ui, enemy, target, range);
        obj.maxDmg = battle.nTurns.atk * enemy.battleStats.dmg;
        if (obj.maxDmg >= target.hp) {
          return obj;
        }
        if (battle.nTurns.def === 0) {
          noRetaliate.push(obj);
        }
      }
      if (noRetaliate.length !== 0) {
        return this.chooseMaxDmg(noRetaliate);
      }
      return this.chooseMaxDmg(inRange);
    };

    EnemyTurn.prototype.doAdvance = function(unit) {
      var afterScroll, attackRange, available, dist, fullPath, i, minDist, moveSpot, obj, path, target, unitAt, _i, _len;
      available = this.getAvailable(unit, {
        noLimit: true
      });
      attackRange = this.movementGetAttackRange(available, unit);
      minDist = Infinity;
      for (_i = 0, _len = attackRange.length; _i < _len; _i++) {
        obj = attackRange[_i];
        dist = unit.pos.distance(obj.moveSpot);
        target = this.ui.chapter.getUnitAt(obj.targetSpot);
        if ((target != null) && target.team instanceof _team.PlayerTeam && dist < minDist) {
          fullPath = obj.path;
          minDist = dist;
        }
      }
      if (fullPath.length - 1 < unit.move) {
        i = fullPath.length - 1;
      } else {
        i = unit.move;
      }
      while (true) {
        moveSpot = fullPath[i];
        path = fullPath.slice(0, i + 1);
        i--;
        unitAt = this.ui.chapter.getUnitAt(moveSpot);
        if (unitAt == null) {
          break;
        }
        if (i < 0) {
          this.doUnitTurn(this.nextUnit);
          return;
        }
      }
      afterScroll = (function(_this) {
        return function() {
          if (!_this.ui.onScreen(moveSpot)) {
            _this.ui.scrollTo(moveSpot, function() {});
          }
          return unit.followPath(path, function() {
            return _this.doUnitTurn(_this.nextUnit);
          });
        };
      })(this);
      if (!this.ui.onScreen(unit.pos)) {
        return this.ui.scrollTo(unit.pos, afterScroll);
      } else {
        return afterScroll();
      }
    };

    EnemyTurn.prototype.spawnUnit = function(toAdd, i) {
      var afterScroll, unit;
      if (i === toAdd.length) {
        this.calcCombatStats();
        return;
      }
      unit = toAdd[i];
      if (this.ui.chapter.getUnitAt(unit.pos) != null) {
        this.spawnUnit(toAdd, i + 1);
        return;
      }
      afterScroll = (function(_this) {
        return function() {
          _this.ui.chapter.addUnit(_this.team, unit);
          return setTimeout((function() {
            return _this.spawnUnit(toAdd, i + 1);
          }), 750 / _this.ui.speedMultiplier);
        };
      })(this);
      if (!this.ui.onScreen(unit.pos)) {
        return this.ui.scrollTo(unit.pos, afterScroll);
      } else {
        return afterScroll();
      }
    };

    EnemyTurn.prototype.spawnReinforcements = function() {
      var toAdd, turnIndex, unit, _i, _len, _ref;
      toAdd = [];
      turnIndex = this.ui.chapter.turnIndex;
      _ref = this.team.reinforcements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        if (unit.spawnTurn === turnIndex) {
          unit.ui = this.ui;
          toAdd.push(unit);
        }
      }
      return this.spawnUnit(toAdd, 0);
    };

    EnemyTurn.prototype.calcCombatStats = function() {
      var unit, _i, _len, _ref;
      _ref = this.team.units;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        unit.calcCombatStats();
      }
      return this.ui.chapter.initTurn(this.ui.chapter.playerTeam);
    };

    return EnemyTurn;

  })(_turn.Turn);

}).call(this);
