// Generated by CoffeeScript 1.7.1
(function() {
  var getRandomPermutation,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  getRandomPermutation = function(k) {
    var i, perm, r, todo, _i, _j, _ref, _ref1, _results;
    todo = (function() {
      _results = [];
      for (var _i = 0, _ref = k - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    perm = [];
    while (todo.length !== 0) {
      r = Math.random();
      for (i = _j = 0, _ref1 = todo.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (r < (i + 1) / todo.length) {
          perm.push(todo.splice(i, 1)[0]);
          break;
        }
      }
    }
    return perm;
  };

  window.Turn = (function() {
    function Turn(ui) {
      this.ui = ui;
      this.afterBattle = __bind(this.afterBattle, this);
      this.directions = [new Position(-1, 0), new Position(1, 0), new Position(0, -1), new Position(0, 1)];
    }

    Turn.prototype.getAvailable = function(unit) {
      var alt, available, dest, dist, i, j, k, map, perm, popClosest, pos, pos2, posDist, prev, prevPos, queue, queuePerm, unitAt, _i, _j, _k, _len, _ref, _ref1, _ref2;
      map = this.ui.chapter.map;
      available = [new Destination(unit.pos, [unit.pos])];
      queue = [];
      queuePerm = getRandomPermutation(map.width * map.height);
      dist = Array(map.height);
      prev = Array(map.height);
      k = 0;
      for (i = _i = 0, _ref = map.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        dist[i] = Array(map.width);
        prev[i] = Array(map.width);
        for (j = _j = 0, _ref1 = map.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          dist[i][j] = Infinity;
          prev[i][j] = null;
          queue[queuePerm[k]] = new Position(i, j);
          k++;
        }
      }
      dist[unit.pos.i][unit.pos.j] = 0;
      popClosest = function() {
        var alt, minDist, minDistK, pos2, _k, _len;
        minDist = Infinity;
        for (k = _k = 0, _len = queue.length; _k < _len; k = ++_k) {
          pos2 = queue[k];
          alt = dist[pos2.i][pos2.j];
          if (alt < minDist) {
            minDist = alt;
            minDistK = k;
          }
        }
        return [queue.splice(minDistK, 1)[0], minDist];
      };
      while (queue.length !== 0) {
        _ref2 = popClosest(), pos = _ref2[0], posDist = _ref2[1];
        if (posDist === Infinity) {
          break;
        }
        perm = getRandomPermutation(this.directions.length);
        for (_k = 0, _len = perm.length; _k < _len; _k++) {
          k = perm[_k];
          pos2 = pos.add(this.directions[k]);
          unitAt = this.ui.chapter.getUnitAt(pos2);
          if (map.onMap(pos2) && !map.tiles[pos2.i][pos2.j].block) {
            alt = posDist + 1;
            if ((unitAt === null || unitAt.team === unit.team) && alt < dist[pos2.i][pos2.j] && alt <= unit.move) {
              dist[pos2.i][pos2.j] = alt;
              prev[pos2.i][pos2.j] = pos;
              dest = new Destination(pos2, [pos2]);
              prevPos = pos;
              while (prevPos !== null) {
                dest.path.unshift(prevPos);
                prevPos = prev[prevPos.i][prevPos.j];
              }
              available.push(dest);
            }
          }
        }
      }
      return available;
    };

    Turn.prototype.getDirections = function(totalRange) {
      var di, dirs, dj, range, _i, _j, _k, _len;
      dirs = [];
      for (_i = 0, _len = totalRange.length; _i < _len; _i++) {
        range = totalRange[_i];
        for (di = _j = -range; -range <= range ? _j <= range : _j >= range; di = -range <= range ? ++_j : --_j) {
          for (dj = _k = -range; -range <= range ? _k <= range : _k >= range; dj = -range <= range ? ++_k : --_k) {
            if (Math.abs(di) + Math.abs(dj) === range) {
              dirs.push(new Position(di, dj));
            }
          }
        }
      }
      return dirs;
    };

    Turn.prototype.getAttackRange = function(unit, pos) {
      var alt, attackRange, dir, _i, _len, _ref;
      attackRange = [];
      _ref = this.getDirections(unit.totalRange);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        alt = pos.add(dir);
        if (this.ui.chapter.map.onMap(alt)) {
          attackRange.push({
            moveSpot: pos,
            targetSpot: alt
          });
        }
      }
      return attackRange;
    };

    Turn.prototype.getActionRange = function(pos, range) {
      var actionRange, alt, dir, _i, _len, _ref;
      actionRange = [];
      _ref = this.getDirections(range);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        alt = pos.add(dir);
        if (this.ui.chapter.map.onMap(alt)) {
          actionRange.push(alt);
        }
      }
      return actionRange;
    };

    Turn.prototype.movementGetAttackRange = function(available, unit) {
      var attackRange, avail, localRange, obj, _i, _j, _len, _len1;
      if (unit == null) {
        unit = this.selectedUnit;
      }
      attackRange = [];
      for (_i = 0, _len = available.length; _i < _len; _i++) {
        avail = available[_i];
        localRange = this.getAttackRange(unit, avail.pos);
        for (_j = 0, _len1 = localRange.length; _j < _len1; _j++) {
          obj = localRange[_j];
          obj.path = avail.path;
          attackRange.push(obj);
        }
      }
      return attackRange;
    };

    Turn.prototype.afterBattle = function() {
      var callback, callback2, increment, playerUnit, toAdd;
      toAdd = this.battle.getExpToAdd();
      playerUnit = this.battle.getPlayerUnit();
      increment = null;
      callback = (function(_this) {
        return function() {
          increment = playerUnit.addExp(toAdd);
          if (increment === null) {
            return _this.afterExpAdd();
          } else {
            return _this.ui.levelUpWindow.init(playerUnit, increment, callback2);
          }
        };
      })(this);
      callback2 = (function(_this) {
        return function() {
          playerUnit.doIncrement(increment);
          return _this.afterExpAdd();
        };
      })(this);
      return this.ui.expBar.init(playerUnit, toAdd, callback);
    };

    return Turn;

  })();

}).call(this);
