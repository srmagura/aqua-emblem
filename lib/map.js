// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Position = (function() {
    function Position(i, j) {
      this.i = i;
      this.j = j;
    }

    Position.prototype.clone = function() {
      return new Position(this.i, this.j);
    };

    Position.prototype.equals = function(pos) {
      return this.i === pos.i && this.j === pos.j;
    };

    Position.prototype.add = function(pos) {
      return new Position(this.i + pos.i, this.j + pos.j);
    };

    Position.prototype.subtract = function(pos) {
      return new Position(this.i - pos.i, this.j - pos.j);
    };

    Position.prototype.scale = function(alpha) {
      return new Position(alpha * this.i, alpha * this.j);
    };

    Position.prototype.distance = function(pos) {
      return Math.abs(this.i - pos.i) + Math.abs(this.j - pos.j);
    };

    Position.prototype.dot = function(pos) {
      return this.i * pos.i + this.j * pos.j;
    };

    Position.prototype.toUnitVector = function() {
      var norm;
      norm = Math.sqrt(this.i * this.i + this.j * this.j);
      return this.scale(1 / norm);
    };

    return Position;

  })();

  window.terrain = {};

  terrain.Terrain = (function() {
    function Terrain(name) {
      this.evade = 0;
      this.def = 0;
      this.block = false;
      this.image = new Image();
      this.image.src = "images/terrain/" + name + ".png";
    }

    return Terrain;

  })();

  terrain.Plain = (function(_super) {
    __extends(Plain, _super);

    function Plain() {
      Plain.__super__.constructor.call(this, 'plain');
      this.name = 'Plain';
    }

    return Plain;

  })(terrain.Terrain);

  terrain.Rocks = (function(_super) {
    __extends(Rocks, _super);

    function Rocks() {
      Rocks.__super__.constructor.call(this, 'rocks');
      this.name = 'Rocks';
      this.block = true;
    }

    return Rocks;

  })(terrain.Terrain);

  terrain.Forest = (function(_super) {
    __extends(Forest, _super);

    function Forest() {
      Forest.__super__.constructor.call(this, 'forest');
      this.name = 'Forest';
      this.evade = 20;
      this.def = 1;
    }

    return Forest;

  })(terrain.Terrain);

  window.OVERLAY_TYPES = {
    AVAILABLE: {
      startColor: '#AAF',
      endColor: '#22F'
    },
    ATTACK: {
      startColor: '#FAA',
      endColor: '#F22'
    }
  };

  window.Map = (function() {
    function Map(rawTiles, terrainMapping, playerPositions) {
      var i, j, t, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      this.height = rawTiles.length;
      this.width = rawTiles[0].length;
      this.tiles = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.tiles.push([]);
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.tiles[i].push(new terrainMapping[rawTiles[i][j]]());
        }
      }
      this.playerPositions = [];
      for (_k = 0, _len = playerPositions.length; _k < _len; _k++) {
        t = playerPositions[_k];
        this.playerPositions.push(new Position(t[0], t[1]));
      }
      this.overlayTiles = [];
      for (i = _l = 0, _ref2 = this.height - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        this.overlayTiles.push([]);
        for (j = _m = 0, _ref3 = this.width - 1; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; j = 0 <= _ref3 ? ++_m : --_m) {
          this.overlayTiles[i].push(null);
        }
      }
    }

    Map.prototype.onMap = function(pos) {
      return 0 <= pos.i && pos.i < this.height && 0 <= pos.j && pos.j < this.width;
    };

    Map.prototype.getTerrain = function(pos) {
      return this.tiles[pos.i][pos.j];
    };

    Map.prototype.setOverlay = function(pos, overlayType) {
      return this.overlayTiles[pos.i][pos.j] = OVERLAY_TYPES[overlayType];
    };

    Map.prototype.clearOverlay = function() {
      var i, j, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.overlayTiles[i][j] = null);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Map.prototype.render = function(ui, ctx) {
      this.renderTiles(ui, ctx);
      return this.renderGrid(ui, ctx);
    };

    Map.prototype.renderTiles = function(ui, ctx) {
      var cw, grd, i, j, overlayTile, tw, x0, y0, _i, _ref, _results;
      tw = ui.tw;
      cw = ui.canvas.width();
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, cw, cw);
      _results = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            x0 = j * tw - ui.origin.j;
            y0 = i * tw - ui.origin.i;
            ctx.drawImage(this.tiles[i][j].image, x0, y0);
            overlayTile = this.overlayTiles[i][j];
            if (overlayTile !== null) {
              ctx.beginPath();
              ctx.rect(x0, y0, tw, tw);
              grd = ctx.createLinearGradient(x0, y0, x0 + tw, y0 + tw);
              grd.addColorStop(0, overlayTile.startColor);
              grd.addColorStop(1, overlayTile.endColor);
              ctx.fillStyle = grd;
              ctx.globalAlpha = .55;
              ctx.fill();
              _results1.push(ctx.globalAlpha = 1);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Map.prototype.renderGrid = function(ui, ctx) {
      var borderColor, drawHorizontal, drawVertical, gridWidth, i, j, normalAlpha, normalColor, tw, _i, _j, _ref, _ref1;
      tw = ui.tw;
      gridWidth = 2;
      ctx.lineWidth = gridWidth;
      borderColor = 'black';
      normalColor = 'black';
      normalAlpha = .10;
      drawHorizontal = (function(_this) {
        return function(i) {
          var offset;
          offset = 0;
          if (i === 0) {
            offset = gridWidth / 2;
          } else if (i === _this.height) {
            offset = -gridWidth / 2;
          }
          if (i === 0 || i === _this.height) {
            ctx.strokeStyle = borderColor;
          } else {
            ctx.strokeStyle = normalColor;
            ctx.globalAlpha = normalAlpha;
          }
          ctx.beginPath();
          ctx.moveTo(offset, i * tw + offset - ui.origin.i);
          ctx.lineTo(_this.width * tw + offset, i * tw + offset - ui.origin.i);
          ctx.stroke();
          return ctx.globalAlpha = 1;
        };
      })(this);
      drawVertical = (function(_this) {
        return function(j) {
          var offset;
          offset = 0;
          if (j === 0) {
            offset = gridWidth / 2;
          } else if (j === _this.width) {
            offset = -gridWidth / 2;
          }
          if (j === 0 || j === _this.width) {
            ctx.strokeStyle = borderColor;
          } else {
            ctx.strokeStyle = normalColor;
            ctx.globalAlpha = normalAlpha;
          }
          ctx.beginPath();
          ctx.moveTo(j * tw + offset - ui.origin.j, offset - ui.origin.i);
          ctx.lineTo(j * tw + offset - ui.origin.j, _this.height * tw + offset);
          ctx.stroke();
          return ctx.globalAlpha = 1;
        };
      })(this);
      for (i = _i = 1, _ref = this.height - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        drawHorizontal(i);
      }
      for (j = _j = 1, _ref1 = this.width - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
        drawVertical(j);
      }
      drawHorizontal(0);
      drawHorizontal(this.height);
      drawVertical(0);
      return drawVertical(this.width);
    };

    return Map;

  })();

}).call(this);
