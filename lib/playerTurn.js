// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.PlayerTurn = (function(_super) {
    __extends(PlayerTurn, _super);

    function PlayerTurn() {
      this.afterExpAdd = __bind(this.afterExpAdd, this);
      this.handleTrade = __bind(this.handleTrade, this);
      this.skillsBoxOnCursorMove = __bind(this.skillsBoxOnCursorMove, this);
      this.skillsBoxOnF = __bind(this.skillsBoxOnF, this);
      this.skillsBoxOnD = __bind(this.skillsBoxOnD, this);
      this.handleSkill = __bind(this.handleSkill, this);
      this.handleAttack = __bind(this.handleAttack, this);
      this.handleWait = __bind(this.handleWait, this);
      this.afterPathFollow = __bind(this.afterPathFollow, this);
      return PlayerTurn.__super__.constructor.apply(this, arguments);
    }

    PlayerTurn.prototype.select = function(selectedUnit) {
      var attackRange, spot, _i, _j, _len, _len1, _ref;
      this.selectedUnit = selectedUnit;
      this.available = this.getAvailable(this.selectedUnit);
      attackRange = this.movementGetAttackRange(this.available);
      for (_i = 0, _len = attackRange.length; _i < _len; _i++) {
        spot = attackRange[_i];
        this.ui.chapter.map.setOverlay(spot.targetSpot, 'ATTACK');
      }
      _ref = this.available;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        spot = _ref[_j];
        this.ui.chapter.map.setOverlay(spot.pos, 'AVAILABLE');
      }
      this.dest = new Destination();
      return this.updateDestination();
    };

    PlayerTurn.prototype.deselect = function() {
      this.selectedUnit = null;
      this.dest = null;
      return this.ui.chapter.map.clearOverlay();
    };

    PlayerTurn.prototype.updateDestination = function() {
      var cp, spot, _i, _len, _ref, _results;
      cp = this.ui.cursor.pos;
      if (this.ui.chapter.map.overlayTiles[cp.i][cp.j] === OVERLAY_TYPES.AVAILABLE) {
        this.dest.pos = cp.clone();
        _ref = this.available;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          spot = _ref[_i];
          if (spot.pos.equals(cp)) {
            this.dest.path = spot.path;
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    PlayerTurn.prototype.initMove = function() {
      var unitAtDest;
      unitAtDest = this.ui.chapter.getUnitAt(this.dest.pos);
      if (unitAtDest !== null && unitAtDest !== this.selectedUnit) {
        return;
      }
      this.selectedUnit.oldPos = this.selectedUnit.pos;
      this.ui.chapter.map.clearOverlay();
      this.ui.cursor.visible = false;
      this.ui.controlState = new ControlState(this.ui);
      this.selectedUnit.followPath(this.dest.path, this.afterPathFollow);
      return this.dest = null;
    };

    PlayerTurn.prototype.afterPathFollow = function() {
      var actions, attackRange, obj, pos, target, _i, _j, _len, _len1, _ref;
      this.ui.unitInfoBox.init(this.selectedUnit, false, true);
      this.ui.unitInfoBox.show();
      attackRange = this.getAttackRange(this.selectedUnit, this.selectedUnit.pos);
      this.inAttackRange = [];
      for (_i = 0, _len = attackRange.length; _i < _len; _i++) {
        obj = attackRange[_i];
        target = this.ui.chapter.getUnitAt(obj.targetSpot);
        if ((target != null) && target.team !== this.selectedUnit.team) {
          this.inAttackRange.push(target);
        }
      }
      this.inTradeRange = [];
      _ref = this.getActionRange(this.selectedUnit.pos, [1]);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        pos = _ref[_j];
        target = this.ui.chapter.getUnitAt(pos);
        if ((target != null) && target.team === this.selectedUnit.team) {
          this.inTradeRange.push(target);
        }
      }
      actions = [];
      if (this.inAttackRange.length !== 0) {
        actions.push(new ActionMenuItem('Attack', this.handleAttack));
      }
      actions.push(new ActionMenuItem('Skill', this.handleSkill));
      if (this.inTradeRange.length !== 0) {
        actions.push(new ActionMenuItem('Trade', this.handleTrade));
      }
      actions.push(new ActionMenuItem('Wait', this.handleWait));
      return this.ui.actionMenu.init(this.selectedUnit, actions);
    };

    PlayerTurn.prototype.handleWait = function() {
      this.ui.cursor.visible = true;
      this.selectedUnit.setDone();
      return this.deselect();
    };

    PlayerTurn.prototype.handleAttack = function() {
      this.ui.actionMenu.hide();
      return this.ui.weaponMenu.init(this);
    };

    PlayerTurn.prototype.handleSkill = function() {
      this.ui.skillsBox.init(this.selectedUnit, this.skillsBoxOnD, this.skillsBoxOnCursorMove);
      this.ui.skillsBox.onF = this.skillsBoxOnF;
      return this.ui.skillsBox.giveControl();
    };

    PlayerTurn.prototype.skillsBoxOnD = function() {
      this.ui.skillsBox.hide();
      return this.ui.actionMenu.init(this.selectedUnit);
    };

    PlayerTurn.prototype.skillsBoxOnF = function() {
      var skl;
      skl = this.ui.skillsBox.getSkill();
      if (!this.selectedUnit.canUseSkill(skl)) {
        return;
      }
      this.ui.skillsBox.hide();
      this.ui.skillInfoBox.init(skl, true);
      this.ui.controlState = skl.getControlState(this.ui, this);
      return this.ui.cursor.visible = true;
    };

    PlayerTurn.prototype.skillsBoxOnCursorMove = function() {
      var skl;
      skl = this.ui.skillsBox.getSkill();
      return this.ui.chapter.map.setOverlayRange(this.selectedUnit.pos, skl.range, skl.overlayType);
    };

    PlayerTurn.prototype.handleTrade = function() {
      this.ui.chapter.map.setOverlayRange(this.selectedUnit.pos, [1], 'AID');
      this.ui.controlState = new CsChooseTradeTarget(this.ui, this);
      this.ui.cursor.visible = true;
      return this.ui.cursor.moveTo(this.inTradeRange[0].pos);
    };

    PlayerTurn.prototype.afterExpAdd = function() {
      this.ui.controlState = new CsMap(this.ui);
      this.ui.cursor.visible = true;
      this.ui.cursor.moveTo(this.selectedUnit.pos);
      this.selectedUnit.setDone();
      return this.selectedUnit = null;
    };

    return PlayerTurn;

  })(Turn);

  window.Destination = (function() {
    function Destination(pos, path) {
      this.pos = pos;
      this.path = path;
    }

    Destination.prototype.render = function(ui, ctx) {
      var dir, k, s, tw, x0, y0;
      tw = ui.tw;
      ctx.beginPath();
      k = 0;
      while (k < this.path.length - 1) {
        ctx.moveTo(this.path[k].j * tw + tw / 2 - ui.origin.j, this.path[k].i * tw + tw / 2 - ui.origin.i);
        ctx.lineTo(this.path[k + 1].j * tw + tw / 2 - ui.origin.j, this.path[k + 1].i * tw + tw / 2 - ui.origin.i);
        k++;
      }
      if (k > 0) {
        s = 10;
        x0 = this.pos.j * tw - ui.origin.j;
        y0 = this.pos.i * tw - ui.origin.i;
        dir = this.pos.subtract(this.path[k - 1]);
        if (dir.equals(new Position(1, 0))) {
          ctx.moveTo(x0 + s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + s);
        } else if (dir.equals(new Position(-1, 0))) {
          ctx.moveTo(x0 + s, y0 + tw - s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + tw - s);
        } else if (dir.equals(new Position(0, 1))) {
          ctx.moveTo(x0 + s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + s, y0 + tw - s);
        } else if (dir.equals(new Position(0, -1))) {
          ctx.moveTo(x0 + tw - s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + tw - s);
        }
        ctx.strokeStyle = '#2266FF';
        ctx.lineWidth = 7;
        ctx.stroke();
        ctx.strokeStyle = '#3399FF';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = '#5BF';
        ctx.lineWidth = 1;
        ctx.stroke();
        return ctx.lineWidth = 2;
      }
    };

    return Destination;

  })();

}).call(this);
