// Generated by CoffeeScript 1.7.1
(function() {
  var getRandomPermutation,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  getRandomPermutation = function(k) {
    var i, perm, r, todo, _i, _j, _ref, _ref1, _results;
    todo = (function() {
      _results = [];
      for (var _i = 0, _ref = k - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    perm = [];
    while (todo.length !== 0) {
      r = Math.random();
      for (i = _j = 0, _ref1 = todo.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (r < (i + 1) / todo.length) {
          perm.push(todo.splice(i, 1)[0]);
          break;
        }
      }
    }
    return perm;
  };

  window.Turn = (function() {
    function Turn(ui) {
      this.ui = ui;
      this.directions = [new Position(-1, 0), new Position(1, 0), new Position(0, -1), new Position(0, 1)];
    }

    Turn.prototype.getAvailable = function(unit) {
      var alt, available, dest, dist, i, j, k, map, perm, popClosest, pos, pos2, posDist, prev, prevPos, queue, queuePerm, unitAt, _i, _j, _k, _len, _ref, _ref1, _ref2;
      map = this.ui.chapter.map;
      available = [new Destination(unit.pos, [unit.pos])];
      queue = [];
      queuePerm = getRandomPermutation(map.width * map.height);
      dist = Array(map.height);
      prev = Array(map.height);
      k = 0;
      for (i = _i = 0, _ref = map.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        dist[i] = Array(map.width);
        prev[i] = Array(map.width);
        for (j = _j = 0, _ref1 = map.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          dist[i][j] = Infinity;
          prev[i][j] = null;
          queue[queuePerm[k]] = new Position(i, j);
          k++;
        }
      }
      dist[unit.pos.i][unit.pos.j] = 0;
      popClosest = function() {
        var alt, minDist, minDistK, pos2, _k, _len;
        minDist = Infinity;
        for (k = _k = 0, _len = queue.length; _k < _len; k = ++_k) {
          pos2 = queue[k];
          alt = dist[pos2.i][pos2.j];
          if (alt < minDist) {
            minDist = alt;
            minDistK = k;
          }
        }
        return [queue.splice(minDistK, 1)[0], minDist];
      };
      while (queue.length !== 0) {
        _ref2 = popClosest(), pos = _ref2[0], posDist = _ref2[1];
        if (posDist === Infinity) {
          break;
        }
        perm = getRandomPermutation(this.directions.length);
        for (_k = 0, _len = perm.length; _k < _len; _k++) {
          k = perm[_k];
          pos2 = pos.add(this.directions[k]);
          unitAt = this.ui.chapter.getUnitAt(pos2);
          if (map.onMap(pos2) && !map.tiles[pos2.i][pos2.j].block) {
            alt = posDist + 1;
            if ((unitAt === null || unitAt.team === unit.team) && alt < dist[pos2.i][pos2.j] && alt <= unit.move) {
              dist[pos2.i][pos2.j] = alt;
              prev[pos2.i][pos2.j] = pos;
              dest = new Destination(pos2, [pos2]);
              prevPos = pos;
              while (prevPos !== null) {
                dest.path.unshift(prevPos);
                prevPos = prev[prevPos.i][prevPos.j];
              }
              available.push(dest);
            }
          }
        }
      }
      return available;
    };

    Turn.prototype.getAttackDirections = function(totalRange) {
      var di, dirs, dj, range, _i, _j, _k, _len;
      dirs = [];
      for (_i = 0, _len = totalRange.length; _i < _len; _i++) {
        range = totalRange[_i];
        for (di = _j = -range; -range <= range ? _j <= range : _j >= range; di = -range <= range ? ++_j : --_j) {
          for (dj = _k = -range; -range <= range ? _k <= range : _k >= range; dj = -range <= range ? ++_k : --_k) {
            if (Math.abs(di) + Math.abs(dj) === range) {
              dirs.push(new Position(di, dj));
            }
          }
        }
      }
      return dirs;
    };

    Turn.prototype.getAttackRange = function(unit, pos) {
      var alt, attackRange, dir, _i, _len, _ref;
      attackRange = [];
      _ref = this.getAttackDirections(unit.totalRange);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        alt = pos.add(dir);
        if (this.ui.chapter.map.onMap(alt)) {
          attackRange.push({
            moveSpot: pos,
            targetSpot: alt
          });
        }
      }
      return attackRange;
    };

    Turn.prototype.movementGetAttackRange = function(available, unit) {
      var attackRange, avail, localRange, obj, _i, _j, _len, _len1;
      if (unit == null) {
        unit = this.selectedUnit;
      }
      attackRange = [];
      for (_i = 0, _len = available.length; _i < _len; _i++) {
        avail = available[_i];
        localRange = this.getAttackRange(unit, avail.pos);
        for (_j = 0, _len1 = localRange.length; _j < _len1; _j++) {
          obj = localRange[_j];
          obj.path = avail.path;
          attackRange.push(obj);
        }
      }
      return attackRange;
    };

    return Turn;

  })();

  window.PlayerTurn = (function(_super) {
    __extends(PlayerTurn, _super);

    function PlayerTurn() {
      this.afterBattle = __bind(this.afterBattle, this);
      this.handleAttack = __bind(this.handleAttack, this);
      this.handleWait = __bind(this.handleWait, this);
      this.afterPathFollow = __bind(this.afterPathFollow, this);
      return PlayerTurn.__super__.constructor.apply(this, arguments);
    }

    PlayerTurn.prototype.select = function(selectedUnit) {
      var attackRange, spot, _i, _j, _len, _len1, _ref;
      this.selectedUnit = selectedUnit;
      this.available = this.getAvailable(this.selectedUnit);
      attackRange = this.movementGetAttackRange(this.available);
      for (_i = 0, _len = attackRange.length; _i < _len; _i++) {
        spot = attackRange[_i];
        this.ui.chapter.map.setOverlay(spot.targetSpot, 'ATTACK');
      }
      _ref = this.available;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        spot = _ref[_j];
        this.ui.chapter.map.setOverlay(spot.pos, 'AVAILABLE');
      }
      this.dest = new Destination();
      return this.updateDestination();
    };

    PlayerTurn.prototype.deselect = function() {
      this.selectedUnit = null;
      this.dest = null;
      return this.ui.chapter.map.clearOverlay();
    };

    PlayerTurn.prototype.updateDestination = function() {
      var cp, spot, _i, _len, _ref, _results;
      cp = this.ui.cursor.pos;
      if (this.ui.chapter.map.overlayTiles[cp.i][cp.j] === OVERLAY_TYPES.AVAILABLE) {
        this.dest.pos = cp.clone();
        _ref = this.available;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          spot = _ref[_i];
          if (spot.pos.equals(cp)) {
            this.dest.path = spot.path;
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    PlayerTurn.prototype.initMove = function() {
      var unitAtDest;
      unitAtDest = this.ui.chapter.getUnitAt(this.dest.pos);
      if (unitAtDest !== null && unitAtDest !== this.selectedUnit) {
        return;
      }
      this.selectedUnit.oldPos = this.selectedUnit.pos;
      this.ui.chapter.map.clearOverlay();
      this.ui.cursor.visible = false;
      this.ui.controlState = new ControlState(this.ui);
      this.selectedUnit.followPath(this.dest.path, this.afterPathFollow);
      return this.dest = null;
    };

    PlayerTurn.prototype.afterPathFollow = function() {
      var actions, attackRange, obj, target, _i, _len;
      this.ui.unitInfoBox.populate(this.selectedUnit);
      this.ui.unitInfoBox.show();
      attackRange = this.getAttackRange(this.selectedUnit, this.selectedUnit.pos);
      this.inRange = [];
      for (_i = 0, _len = attackRange.length; _i < _len; _i++) {
        obj = attackRange[_i];
        this.ui.chapter.map.setOverlay(obj.targetSpot, 'ATTACK');
        target = this.ui.chapter.getUnitAt(obj.targetSpot);
        if ((target != null) && target.team !== this.selectedUnit.team) {
          this.inRange.push(target);
        }
      }
      actions = [];
      if (this.inRange.length !== 0) {
        actions.push(new ActionMenuItem('Attack', this.handleAttack));
      }
      actions.push(new ActionMenuItem('Wait', this.handleWait));
      return this.ui.actionMenu.init(actions);
    };

    PlayerTurn.prototype.handleWait = function() {
      this.ui.cursor.visible = true;
      this.selectedUnit.setDone();
      return this.deselect();
    };

    PlayerTurn.prototype.handleAttack = function() {
      this.ui.cursor.visible = false;
      this.ui.actionMenu.hide();
      return this.ui.weaponMenu.init(this);
    };

    PlayerTurn.prototype.afterBattle = function() {
      this.ui.controlState = new CsMap(this.ui);
      this.ui.cursor.visible = true;
      this.ui.cursor.moveTo(this.selectedUnit.pos);
      this.selectedUnit.setDone();
      return this.selectedUnit = null;
    };

    return PlayerTurn;

  })(Turn);

  window.Destination = (function() {
    function Destination(pos, path) {
      this.pos = pos;
      this.path = path;
    }

    Destination.prototype.render = function(ui, ctx) {
      var dir, k, s, tw, x0, y0;
      tw = ui.tw;
      ctx.beginPath();
      k = 0;
      while (k < this.path.length - 1) {
        ctx.moveTo(this.path[k].j * tw + tw / 2 - ui.origin.j, this.path[k].i * tw + tw / 2 - ui.origin.i);
        ctx.lineTo(this.path[k + 1].j * tw + tw / 2 - ui.origin.j, this.path[k + 1].i * tw + tw / 2 - ui.origin.i);
        k++;
      }
      if (k > 0) {
        s = 10;
        x0 = this.pos.j * tw - ui.origin.j;
        y0 = this.pos.i * tw - ui.origin.i;
        dir = this.pos.subtract(this.path[k - 1]);
        if (dir.equals(new Position(1, 0))) {
          ctx.moveTo(x0 + s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + s);
        } else if (dir.equals(new Position(-1, 0))) {
          ctx.moveTo(x0 + s, y0 + tw - s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + tw - s);
        } else if (dir.equals(new Position(0, 1))) {
          ctx.moveTo(x0 + s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + s, y0 + tw - s);
        } else if (dir.equals(new Position(0, -1))) {
          ctx.moveTo(x0 + tw - s, y0 + s);
          ctx.lineTo(x0 + tw / 2, y0 + tw / 2);
          ctx.lineTo(x0 + tw - s, y0 + tw - s);
        }
        ctx.strokeStyle = '#2266FF';
        ctx.lineWidth = 7;
        ctx.stroke();
        ctx.strokeStyle = '#3399FF';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = '#5BF';
        ctx.lineWidth = 1;
        ctx.stroke();
        return ctx.lineWidth = 2;
      }
    };

    return Destination;

  })();

}).call(this);
