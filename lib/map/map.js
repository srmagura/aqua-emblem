// Generated by CoffeeScript 1.12.2
(function() {
  window._map = {};

  _map.OVERLAY_TYPES = {
    AVAILABLE: {
      startColor: '#AAF',
      endColor: '#22F'
    },
    ATTACK: {
      startColor: '#FAA',
      endColor: '#F22'
    },
    AID: {
      startColor: '#AFA',
      endColor: '#2F2'
    },
    DAMAGE: {
      startColor: '#ffe6aa',
      endColor: '#d28704'
    }
  };

  _map.Map = (function() {
    function Map(rawTiles, terrainMapping, playerPositions) {
      var i, j, k, l, len, m, n, o, ref, ref1, ref2, ref3, t;
      this.height = rawTiles.length;
      this.width = rawTiles[0].length;
      this.tiles = [];
      for (i = k = 0, ref = this.height - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.tiles.push([]);
        for (j = l = 0, ref1 = this.width - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
          this.tiles[i].push(new terrainMapping[rawTiles[i][j]]());
        }
      }
      this.playerPositions = [];
      for (m = 0, len = playerPositions.length; m < len; m++) {
        t = playerPositions[m];
        this.playerPositions.push(new Position(t[0], t[1]));
      }
      this.overlayTiles = [];
      for (i = n = 0, ref2 = this.height - 1; 0 <= ref2 ? n <= ref2 : n >= ref2; i = 0 <= ref2 ? ++n : --n) {
        this.overlayTiles.push([]);
        for (j = o = 0, ref3 = this.width - 1; 0 <= ref3 ? o <= ref3 : o >= ref3; j = 0 <= ref3 ? ++o : --o) {
          this.overlayTiles[i].push(null);
        }
      }
    }

    Map.prototype.onMap = function(pos) {
      return 0 <= pos.i && pos.i < this.height && 0 <= pos.j && pos.j < this.width;
    };

    Map.prototype.getTerrain = function(pos) {
      return this.tiles[pos.i][pos.j];
    };

    Map.prototype.setOverlay = function(pos, overlayType) {
      return this.overlayTiles[pos.i][pos.j] = _map.OVERLAY_TYPES[overlayType];
    };

    Map.prototype.setOverlayRange = function(pos, range, overlayType) {
      var k, len, results, spot, spots;
      this.clearOverlay();
      spots = this.ui.staticTurn.getActionRange(pos, range);
      results = [];
      for (k = 0, len = spots.length; k < len; k++) {
        spot = spots[k];
        results.push(this.setOverlay(spot, overlayType));
      }
      return results;
    };

    Map.prototype.clearOverlay = function() {
      var i, j, k, ref, results;
      results = [];
      for (i = k = 0, ref = this.height - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (j = l = 0, ref1 = this.width - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            results1.push(this.overlayTiles[i][j] = null);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Map.prototype.render = function(ui, ctx) {
      this.renderTiles(ui, ctx);
      return this.renderGrid(ui, ctx);
    };

    Map.prototype.renderTiles = function(ui, ctx) {
      var cw, grd, i, j, k, overlayTile, ref, results, tw, x0, y0;
      tw = ui.tw;
      cw = ui.canvas.width();
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, cw, cw);
      results = [];
      for (i = k = 0, ref = this.height - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (j = l = 0, ref1 = this.width - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            x0 = j * tw - ui.origin.j;
            y0 = i * tw - ui.origin.i;
            ctx.drawImage(this.tiles[i][j].image, x0, y0);
            overlayTile = this.overlayTiles[i][j];
            if (overlayTile !== null) {
              ctx.beginPath();
              ctx.rect(x0, y0, tw, tw);
              grd = ctx.createLinearGradient(x0, y0, x0 + tw, y0 + tw);
              grd.addColorStop(0, overlayTile.startColor);
              grd.addColorStop(1, overlayTile.endColor);
              ctx.fillStyle = grd;
              ctx.globalAlpha = .55;
              ctx.fill();
              results1.push(ctx.globalAlpha = 1);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Map.prototype.renderGrid = function(ui, ctx) {
      var borderColor, drawHorizontal, drawVertical, gridWidth, i, j, k, l, normalAlpha, normalColor, ref, ref1, tw;
      tw = ui.tw;
      gridWidth = 2;
      ctx.lineWidth = gridWidth;
      borderColor = 'black';
      normalColor = 'black';
      normalAlpha = .10;
      drawHorizontal = (function(_this) {
        return function(i) {
          var offset;
          offset = 0;
          if (i === 0) {
            offset = gridWidth / 2;
          } else if (i === _this.height) {
            offset = -gridWidth / 2;
          }
          if (i === 0 || i === _this.height) {
            ctx.strokeStyle = borderColor;
          } else {
            ctx.strokeStyle = normalColor;
            ctx.globalAlpha = normalAlpha;
          }
          ctx.beginPath();
          ctx.moveTo(offset, i * tw + offset - ui.origin.i);
          ctx.lineTo(_this.width * tw + offset, i * tw + offset - ui.origin.i);
          ctx.stroke();
          return ctx.globalAlpha = 1;
        };
      })(this);
      drawVertical = (function(_this) {
        return function(j) {
          var offset;
          offset = 0;
          if (j === 0) {
            offset = gridWidth / 2;
          } else if (j === _this.width) {
            offset = -gridWidth / 2;
          }
          if (j === 0 || j === _this.width) {
            ctx.strokeStyle = borderColor;
          } else {
            ctx.strokeStyle = normalColor;
            ctx.globalAlpha = normalAlpha;
          }
          ctx.beginPath();
          ctx.moveTo(j * tw + offset - ui.origin.j, offset - ui.origin.i);
          ctx.lineTo(j * tw + offset - ui.origin.j, _this.height * tw + offset);
          ctx.stroke();
          return ctx.globalAlpha = 1;
        };
      })(this);
      for (i = k = 1, ref = this.height - 1; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        drawHorizontal(i);
      }
      for (j = l = 1, ref1 = this.width - 1; 1 <= ref1 ? l <= ref1 : l >= ref1; j = 1 <= ref1 ? ++l : --l) {
        drawVertical(j);
      }
      drawHorizontal(0);
      drawHorizontal(this.height);
      drawVertical(0);
      return drawVertical(this.width);
    };

    return Map;

  })();

}).call(this);
